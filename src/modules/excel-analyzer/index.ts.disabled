import ExcelJS from 'exceljs'
import { AnalysisModule, AnalysisResult, ExcelAnalyzerOptions } from './types'
import { CircularReferenceModule } from './modules/circular-reference'
import { DataTypeCheckerModule } from './modules/data-type-checker'
import { FormulaOptimizerModule } from './modules/formula-optimizer'
import { FormulaEngine } from '../../lib/excel/formula-engine'

export class ExcelAnalyzer {
  private modules: Map<string, AnalysisModule> = new Map()
  private options: ExcelAnalyzerOptions
  private formulaEngine: FormulaEngine
  
  constructor(options: ExcelAnalyzerOptions = {}) {
    this.options = {
      maxErrors: 100,
      ...options
    }
    
    // HyperFormula ì—”ì§„ ì´ˆê¸°í™”
    this.formulaEngine = new FormulaEngine()
    
    // ê¸°ë³¸ ëª¨ë“ˆ ë“±ë¡
    if (!options.modules) {
      this.registerModule(new CircularReferenceModule())
      this.registerModule(new DataTypeCheckerModule())
      this.registerModule(new FormulaOptimizerModule())
    } else {
      options.modules.forEach(module => this.registerModule(module))
    }
  }
  
  registerModule(module: AnalysisModule) {
    this.modules.set(module.name, module)
  }
  
  async analyze(fileBuffer: Buffer | ArrayBuffer): Promise<AnalysisResult[]> {
    const workbook = new ExcelJS.Workbook()
    // Convert ArrayBuffer to Buffer if needed
    const buffer = Buffer.isBuffer(fileBuffer) ? fileBuffer : 
                   fileBuffer instanceof ArrayBuffer ? Buffer.from(fileBuffer) :
                   Buffer.from(fileBuffer as any)
    await workbook.xlsx.load(buffer)
    
    const allResults: AnalysisResult[] = []
    const skipModules = new Set(this.options.skipModules || [])
    
    try {
      // HyperFormulaì— ì›Œí¬ë¶ ë¡œë“œ
      await this.formulaEngine.loadWorkbook(workbook)
      
      // ê³ ê¸‰ ìˆ˜ì‹ ë¶„ì„ ìˆ˜í–‰
      const formulaResults = await this.analyzeFormulasWithHyperFormula(workbook)
      allResults.push(...formulaResults)
      
    } catch (error) {
      console.error('HyperFormula analysis error:', error)
      allResults.push({
        type: 'warning',
        severity: 'medium',
        location: 'Formula Engine',
        message: 'HyperFormula ë¶„ì„ ì¤‘ ì¼ë¶€ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤',
        code: 'FORMULA_ENGINE_WARNING',
        metadata: { error: String(error) }
      })
    }
    
    // ê° ëª¨ë“ˆ ì‹¤í–‰
    for (const [name, module] of this.modules) {
      if (skipModules.has(name)) continue
      
      try {
        console.log(`Running analysis module: ${name}`)
        const results = await module.analyze(workbook)
        allResults.push(...results)
        
        // ìµœëŒ€ ì˜¤ë¥˜ ìˆ˜ ì²´í¬
        if (allResults.length >= this.options.maxErrors!) {
          break
        }
      } catch (error) {
        console.error(`Error in module ${name}:`, error)
        allResults.push({
          type: 'error',
          severity: 'high',
          location: 'Analysis Module',
          message: `ë¶„ì„ ëª¨ë“ˆ ${name} ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ`,
          code: 'MODULE_ERROR',
          metadata: { error: String(error) }
        })
      }
    }
    
    // ê²°ê³¼ ì •ë ¬ (ì‹¬ê°ë„ ìˆœ)
    return this.sortResults(allResults)
  }
  
  private sortResults(results: AnalysisResult[]): AnalysisResult[] {
    const severityOrder = { high: 0, medium: 1, low: 2 }
    const typeOrder = { error: 0, warning: 1, suggestion: 2 }
    
    return results.sort((a, b) => {
      // ë¨¼ì € íƒ€ì…ìœ¼ë¡œ ì •ë ¬
      const typeDiff = typeOrder[a.type] - typeOrder[b.type]
      if (typeDiff !== 0) return typeDiff
      
      // ê°™ì€ íƒ€ì…ì´ë©´ ì‹¬ê°ë„ë¡œ ì •ë ¬
      return severityOrder[a.severity] - severityOrder[b.severity]
    })
  }
  
  async generateReport(results: AnalysisResult[]): Promise<string> {
    const grouped = this.groupResults(results)
    let report = '# Excel ë¶„ì„ ë³´ê³ ì„œ\n\n'
    
    report += `## ìš”ì•½\n`
    report += `- ì´ ${results.length}ê°œ í•­ëª© ë°œê²¬\n`
    report += `- ì˜¤ë¥˜: ${grouped.error?.length || 0}ê°œ\n`
    report += `- ê²½ê³ : ${grouped.warning?.length || 0}ê°œ\n`
    report += `- ì œì•ˆ: ${grouped.suggestion?.length || 0}ê°œ\n\n`
    
    if (grouped.error && grouped.error.length > 0) {
      report += `## ğŸ”´ ì˜¤ë¥˜ (${grouped.error.length}ê°œ)\n\n`
      grouped.error.forEach((result, idx) => {
        report += `### ${idx + 1}. ${result.message}\n`
        report += `- ìœ„ì¹˜: ${result.location}\n`
        report += `- ì‹¬ê°ë„: ${result.severity}\n`
        if (result.suggestion) {
          report += `- í•´ê²° ë°©ë²•: ${result.suggestion}\n`
        }
        report += '\n'
      })
    }
    
    if (grouped.warning && grouped.warning.length > 0) {
      report += `## ğŸŸ¡ ê²½ê³  (${grouped.warning.length}ê°œ)\n\n`
      grouped.warning.forEach((result, idx) => {
        report += `### ${idx + 1}. ${result.message}\n`
        report += `- ìœ„ì¹˜: ${result.location}\n`
        if (result.suggestion) {
          report += `- ê¶Œì¥ ì‚¬í•­: ${result.suggestion}\n`
        }
        report += '\n'
      })
    }
    
    if (grouped.suggestion && grouped.suggestion.length > 0) {
      report += `## ğŸ’¡ ê°œì„  ì œì•ˆ (${grouped.suggestion.length}ê°œ)\n\n`
      grouped.suggestion.forEach((result, idx) => {
        report += `### ${idx + 1}. ${result.message}\n`
        report += `- ìœ„ì¹˜: ${result.location}\n`
        report += `- ì œì•ˆ: ${result.suggestion}\n`
        report += '\n'
      })
    }
    
    return report
  }
  
  private groupResults(results: AnalysisResult[]): Record<string, AnalysisResult[]> {
    return results.reduce((acc, result) => {
      if (!acc[result.type]) acc[result.type] = []
      acc[result.type].push(result)
      return acc
    }, {} as Record<string, AnalysisResult[]>)
  }
  
  /**
   * HyperFormulaë¥¼ ì‚¬ìš©í•œ ê³ ê¸‰ ìˆ˜ì‹ ë¶„ì„
   */
  private async analyzeFormulasWithHyperFormula(workbook: ExcelJS.Workbook): Promise<AnalysisResult[]> {
    const results: AnalysisResult[] = []
    
    try {
      // ëª¨ë“  ì›Œí¬ì‹œíŠ¸ì˜ ìˆ˜ì‹ ë¶„ì„
      for (const worksheet of workbook.worksheets) {
        const sheetName = worksheet.name
        
        worksheet.eachRow((row, rowNumber) => {
          row.eachCell((cell, colNumber) => {
            if (cell.type === ExcelJS.ValueType.Formula && cell.formula) {
              try {
                // HyperFormulaë¡œ ìˆ˜ì‹ ë¶„ì„
                const analysis = this.formulaEngine.analyzeFormula(cell.formula, sheetName)
                const location = `${sheetName}!${this.columnToLetter(colNumber)}${rowNumber}`
                
                // ìˆ˜ì‹ ê²€ì¦ ê²°ê³¼ ì²˜ë¦¬
                if (!analysis.validation.isValid) {
                  results.push({
                    type: 'error',
                    severity: this.getErrorSeverity(analysis.validation.errorType),
                    location,
                    message: `ìˆ˜ì‹ ì˜¤ë¥˜: ${analysis.validation.error}`,
                    code: analysis.validation.errorType || 'FORMULA_ERROR',
                    suggestion: this.getFormulaSuggestion(analysis.validation.errorType),
                    metadata: {
                      formula: cell.formula,
                      errorType: analysis.validation.errorType,
                      originalValue: cell.value
                    }
                  })
                }
                
                // ì„±ëŠ¥ ìµœì í™” ì œì•ˆ
                if (analysis.optimization) {
                  results.push({
                    type: 'suggestion',
                    severity: 'low',
                    location,
                    message: analysis.optimization.suggestion,
                    code: 'FORMULA_OPTIMIZATION',
                    suggestion: `ë³€ê²½ ì „: ${analysis.optimization.original}\në³€ê²½ í›„: ${analysis.optimization.optimized}`,
                    metadata: {
                      originalFormula: analysis.optimization.original,
                      optimizedFormula: analysis.optimization.optimized,
                      performanceGain: analysis.optimization.performanceGain
                    }
                  })
                }
                
                // ë³µì¡ë„ ê²½ê³ 
                if (analysis.complexity === 'complex') {
                  results.push({
                    type: 'warning',
                    severity: 'medium',
                    location,
                    message: 'ë³µì¡í•œ ìˆ˜ì‹ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤. ì„±ëŠ¥ì— ì˜í–¥ì„ ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                    code: 'COMPLEX_FORMULA',
                    suggestion: 'ìˆ˜ì‹ì„ ë‹¨ìˆœí™”í•˜ê±°ë‚˜ ì—¬ëŸ¬ ì…€ë¡œ ë¶„í• í•˜ëŠ” ê²ƒì„ ê³ ë ¤í•´ë³´ì„¸ìš”.',
                    metadata: {
                      formula: cell.formula,
                      complexity: analysis.complexity,
                      dependencies: analysis.dependencies
                    }
                  })
                }
                
                // íœ˜ë°œì„± í•¨ìˆ˜ ê²½ê³ 
                if (analysis.volatileFunctions.length > 0) {
                  results.push({
                    type: 'warning',
                    severity: 'medium',
                    location,
                    message: `íœ˜ë°œì„± í•¨ìˆ˜ê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤: ${analysis.volatileFunctions.join(', ')}`,
                    code: 'VOLATILE_FUNCTION',
                    suggestion: 'íœ˜ë°œì„± í•¨ìˆ˜ëŠ” ë§¤ë²ˆ ì¬ê³„ì‚°ë˜ì–´ ì„±ëŠ¥ì— ì˜í–¥ì„ ì¤ë‹ˆë‹¤. ê°€ëŠ¥í•˜ë©´ ì •ì  ê°’ìœ¼ë¡œ ëŒ€ì²´í•˜ì„¸ìš”.',
                    metadata: {
                      formula: cell.formula,
                      volatileFunctions: analysis.volatileFunctions
                    }
                  })
                }
                
              } catch (error) {
                // ê°œë³„ ìˆ˜ì‹ ë¶„ì„ ì˜¤ë¥˜ëŠ” ë¬´ì‹œí•˜ê³  ê³„ì† ì§„í–‰
                console.warn(`Formula analysis error at ${sheetName}!${this.columnToLetter(colNumber)}${rowNumber}:`, error)
              }
            }
          })
        })
      }
      
      // ìˆœí™˜ ì°¸ì¡° ê°ì§€
      const circularRefs = this.formulaEngine.detectCircularReferences()
      circularRefs.forEach(ref => {
        results.push({
          type: 'error',
          severity: 'high',
          location: ref.cells.join(', '),
          message: ref.description,
          code: 'CIRCULAR_REFERENCE',
          suggestion: 'ìˆœí™˜ ì°¸ì¡°ë¥¼ ì œê±°í•˜ì—¬ ë¬´í•œ ê³„ì‚°ì„ ë°©ì§€í•˜ì„¸ìš”.',
          metadata: {
            involvedCells: ref.cells
          }
        })
      })
      
    } catch (error) {
      console.error('HyperFormula analysis error:', error)
      results.push({
        type: 'warning',
        severity: 'medium',
        location: 'Formula Analysis',
        message: 'ì¼ë¶€ ìˆ˜ì‹ ë¶„ì„ì„ ì™„ë£Œí•  ìˆ˜ ì—†ì—ˆìŠµë‹ˆë‹¤',
        code: 'ANALYSIS_INCOMPLETE',
        metadata: { error: String(error) }
      })
    }
    
    return results
  }
  
  /**
   * ì˜¤ë¥˜ íƒ€ì…ì— ë”°ë¥¸ ì‹¬ê°ë„ ê²°ì •
   */
  private getErrorSeverity(errorType?: string): 'high' | 'medium' | 'low' {
    const highSeverityErrors = ['DIV_BY_ZERO', 'CIRCULAR_REFERENCE', 'REF']
    const mediumSeverityErrors = ['VALUE', 'NUM', 'NAME']
    
    if (!errorType) return 'medium'
    if (highSeverityErrors.includes(errorType)) return 'high'
    if (mediumSeverityErrors.includes(errorType)) return 'medium'
    return 'low'
  }
  
  /**
   * ì˜¤ë¥˜ íƒ€ì…ì— ë”°ë¥¸ ìˆ˜ì • ì œì•ˆ
   */
  private getFormulaSuggestion(errorType?: string): string {
    const suggestions: Record<string, string> = {
      'DIV_BY_ZERO': '0ìœ¼ë¡œ ë‚˜ëˆ„ëŠ” ë¶€ë¶„ì„ í™•ì¸í•˜ê³  IF í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì¡°ê±´ë¶€ ê³„ì‚°ì„ êµ¬í˜„í•˜ì„¸ìš”.',
      'VALUE': 'ë°ì´í„° íƒ€ì…ì„ í™•ì¸í•˜ê³  ì ì ˆí•œ ë³€í™˜ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.',
      'NUM': 'ìˆ«ì ë²”ìœ„ì™€ í˜•ì‹ì„ í™•ì¸í•˜ì„¸ìš”.',
      'NAME': 'í•¨ìˆ˜ëª…ê³¼ ì…€ ì°¸ì¡°ë¥¼ í™•ì¸í•˜ì„¸ìš”.',
      'REF': 'ì‚­ì œëœ ì…€ì´ë‚˜ ì‹œíŠ¸ì— ëŒ€í•œ ì°¸ì¡°ë¥¼ ìˆ˜ì •í•˜ì„¸ìš”.',
      'CIRCULAR_REFERENCE': 'ìˆœí™˜ ì°¸ì¡°ë¥¼ ì œê±°í•˜ì—¬ ê³„ì‚° ë£¨í”„ë¥¼ ë°©ì§€í•˜ì„¸ìš”.'
    }
    
    return suggestions[errorType || ''] || 'ìˆ˜ì‹ì„ ê²€í† í•˜ê³  ìˆ˜ì •í•˜ì„¸ìš”.'
  }
  
  /**
   * ì—´ ë²ˆí˜¸ë¥¼ ë¬¸ìë¡œ ë³€í™˜ (1 -> A, 2 -> B, ...)
   */
  private columnToLetter(column: number): string {
    let result = ''
    while (column > 0) {
      column--
      result = String.fromCharCode(65 + (column % 26)) + result
      column = Math.floor(column / 26)
    }
    return result
  }
  
  /**
   * ì—”ì§„ ì •ë¦¬
   */
  destroy(): void {
    if (this.formulaEngine) {
      this.formulaEngine.destroy()
    }
  }
}

// Export types and modules
export * from './types'
export { CircularReferenceModule } from './modules/circular-reference'
export { DataTypeCheckerModule } from './modules/data-type-checker'
export { FormulaOptimizerModule } from './modules/formula-optimizer'